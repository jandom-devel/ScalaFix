/**
 * Copyright 2015, 2016, 2017 Gianluca Amato <gianluca.amato@unich.it>
 *
 * This file is part of ScalaFix. ScalaFix is free software: you can
 * redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ScalaFix is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of a MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ScalaFix. If not, see <http://www.gnu.org/licenses/>.
 */

package it.unich.scalafix.graphs

import it.unich.scalafix.*
import it.unich.scalafix.finite.*
import it.unich.scalafix.assignments.MapBasedMutableAssignment
import it.unich.scalafix.lattice.{Domain, Magma}
import it.unich.scalafix.utils.Relation

/**
 * This is the abstract class for a finite equation system generated by an
 * hyper-graph. Unknowns are nodes of the graph. Given an assignment, each
 * hyper-edge produces a partial values. These values are combined with the
 * upper bound operation of the domain `V`.
 */
trait GraphEquationSystem[U, V, EQS <: GraphEquationSystem[U, V, EQS]]
    extends FiniteEquationSystem[U, V, EQS]:

  /**
   * Add combos to the equation system in a localized way.
   *
   * @param combos
   *   new combos to add.
   * @param ordering
   *   an order on unknown used to decide which edges needs to be widened
   */
  def withLocalizedCombos(
      combos: ComboAssignment[U, V],
      ordering: Ordering[U]
  ): EQS

  /**
   * Add warrowing to the equation system in a localized way. Localized
   * warrowing requires a different procedure than standard localized widenings.
   * Moreover, it is not entirely clear whether this works as intended or not.
   *
   * @param widenings
   *   a widening assignment
   * @param narrowings
   *   a narrowing assignment
   */
  def withLocalizedWarrowing(
      widenings: ComboAssignment[U, V],
      narrowings: ComboAssignment[U, V],
      ordering: Ordering[U]
  ): EQS

/**
 * A simple standard implementation of GraphEquationSystem. All fields must be
 * provided explicitly by the user with the exception of `body`,
 * `bodyWithDependencies` and `infl` which are computed by the graph.
 */
abstract class BaseGraphEquationSystem[U, V: Domain, E, EQS <: BaseGraphEquationSystem[U, V, E, EQS]]
    extends BaseFiniteEquationSystem[U, V, EQS]
    with GraphEquationSystem[U, V, EQS]
    with Cloneable:

  protected val _graph: Graph[U, V, E]
  protected var optLocalizedCombos: Option[ComboAssignment[U, V]] = None
  protected var optLocalizedWidenings: Option[ComboAssignment[U, V]] = None
  protected var optLocalizedNarrowings: Option[ComboAssignment[U, V]] = None
  protected var optLocalizedOrdering: Option[Ordering[U]] = None

  override protected def _body: Body[U, V] =
    if optLocalizedWidenings.isDefined && optLocalizedNarrowings.isDefined && optLocalizedOrdering.isDefined
    then
      graph.addLocalizedWarrowing(
        optLocalizedWidenings.get,
        optLocalizedNarrowings.get,
        optLocalizedOrdering.get
      )
    else graph

  protected def graph: Graph[U, V, E] =
    if (optLocalizedCombos.isDefined && optLocalizedOrdering.isDefined)
    then _graph.addLocalizedCombos(optLocalizedCombos.get, optLocalizedOrdering.get)
    else _graph

  override def bodyWithDependencies: BodyWithDependencies[U, V] =
    (rho: Assignment[U, V]) =>
      (x: U) => {
        val deps =
          graph
            .ingoing(x)
            .foldLeft(Iterable.empty[U])((acc: Iterable[U], e: E) => acc ++ graph.sources(e))
        val res = body(rho)(x)
        (res, deps)
      }

  override def _infl: Relation[U] = Relation((u: U) => graph.outgoing(u).view.map(graph.target).toSet)

  override def infl =
    if optLocalizedWidenings.isEmpty || optLocalizedWidenings.isEmpty || optLocalizedOrdering.isEmpty ||
      (optLocalizedWidenings.get.combosAreIdempotent && optLocalizedNarrowings.get.combosAreIdempotent)
    then super.infl
    else super.infl.withDiagonal

  def withLocalizedCombos(
      combos: ComboAssignment[U, V],
      ordering: Ordering[U]
  ): EQS =
    val clone = this.clone()
    clone.optLocalizedCombos = Some(combos)
    clone.optLocalizedOrdering = Some(ordering)
    clone.optLocalizedWidenings = None
    clone.optLocalizedNarrowings = None
    clone

  def withLocalizedWarrowing(
      widenings: ComboAssignment[U, V],
      narrowings: ComboAssignment[U, V],
      ordering: Ordering[U]
  ): EQS =
    val clone = this.clone()
    clone.optLocalizedWidenings = Some(widenings)
    clone.optLocalizedNarrowings = Some(narrowings)
    clone.optLocalizedOrdering = Some(ordering)
    clone.optLocalizedCombos = None
    clone

class SimpleGraphEquationSystem[U, V: Domain, E](
    protected val _graph: Graph[U, V, E],
    val inputUnknowns: Set[U],
    val unknowns: Iterable[U],

) extends BaseGraphEquationSystem[U, V, E, SimpleGraphEquationSystem[U, V, E]]

object GraphEquationSystem:
  /**
   * Returns the standard implementation of GraphEquationSystem. All fields must
   * be provided explicitly by the user with the exception of `body`,
   * `bodyWithDependencies` and `infl`.
   */
  def apply[U, V: Domain, E](
      graph: Graph[U, V, E],
      unknowns: Iterable[U],
      inputUnknowns: Set[U]
  ): SimpleGraphEquationSystem[U, V, E] =
    SimpleGraphEquationSystem(
      graph,
      inputUnknowns,
      unknowns
    )
