/**
 * Copyright 2015, 2016 Gianluca Amato <gianluca.amato@unich.it>
 *
 * This file is part of ScalaFix. ScalaFix is free software: you can
 * redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ScalaFix is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of a MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ScalaFix. If not, see <http://www.gnu.org/licenses/>.
 */

package it.unich.scalafix.finite

import it.unich.scalafix.utils.Relation
import org.scalatest.funspec.AnyFunSpec
import org.scalatestplus.scalacheck.ScalaCheckPropertyChecks

class DFOrderingTest extends AnyFunSpec with ScalaCheckPropertyChecks {

  import DFOrdering.EdgeType.*

  // This example comes from "Aho, Sethi, Ullman - Compilers: Principles, Techniques and Tool - Addison Wesley"
  private val graph = Relation(
    Seq(
      1 -> 3,
      1 -> 2,
      2 -> 3,
      3 -> 4,
      4 -> 6,
      4 -> 5,
      4 -> 8,
      5 -> 7,
      6 -> 7,
      7 -> 4,
      7 -> 8,
      8 -> 4,
      8 -> 3,
      8 -> 10,
      8 -> 9,
      9 -> 1,
      10 -> 7
    )
  )
  private val heads = Set(1, 3, 4, 7)
  private val sequence = 1 to 10
  private val advancing =
    Set(1 -> 2, 1 -> 3, 3 -> 4, 4 -> 5, 4 -> 6, 6 -> 7, 7 -> 8, 8 -> 9, 8 -> 10, 4 -> 8)
  private val retreating = Set(10 -> 7, 9 -> 1, 8 -> 3, 7 -> 4, 4 -> 3)
  private val cross = Set(2 -> 3, 5 -> 7)

  private val graph2 = Relation(
    Seq(
      1 -> 2,
      1 -> 3,
      2 -> 3,
      3 -> 4,
      4 -> 6,
      4 -> 5,
      4 -> 8,
      5 -> 7,
      6 -> 7,
      7 -> 4,
      7 -> 8,
      8 -> 4,
      8 -> 3,
      8 -> 9,
      8 -> 10,
      9 -> 1,
      10 -> 7
    )
  )
  private val sequence2 = (1 to 8).toList :+ 10 :+ 9

  describe("The depth-first ordering generated by the example graph") {
    val o = DFOrdering(graph, sequence, List(1))

    it("has the correct sequence") {
      assertResult(sequence)(o.toSeq)
    }

    it("has the correct heads") {
      for x <- sequence do assertResult(heads contains x)(o.isHead(x))
    }
    it("has the correct edge types") {
      for (u, v) <- advancing do assertResult(Advancing, s"($u,$v)")(o.edgeType(u, v))
    }
    for (u, v) <- retreating do assertResult(Retreating)(o.edgeType(u, v))
    for (u, v) <- cross do assertResult(Cross)(o.edgeType(u, v))

    it("implements the correct ordering") {
      for x <- sequence; y <- sequence do
        assertResult(
          scala.math.signum(sequence.indexOf(x) compare sequence.indexOf(y)),
          s"$x <= $y"
        ) {
          scala.math.signum(o.compare(x, y))
        }
    }

    describe("The depth-first ordering generated by a permutation of the example graph") {
      it("has a different ordering of elements") {
        val o2 = DFOrdering(graph2, sequence2, List(1))
        assertResult(sequence2)(o2.toSeq)
      }
    }
  }
}
