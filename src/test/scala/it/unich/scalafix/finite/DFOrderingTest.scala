/**
  * Copyright 2015, 2016 Gianluca Amato <gianluca.amato@unich.it>
  *
  * This file is part of ScalaFix.
  * ScalaFix is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * ScalaFix is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty ofa
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with ScalaFix.  If not, see <http://www.gnu.org/licenses/>.
  */

package it.unich.scalafix.finite

import it.unich.scalafix.utils.Relation
import org.scalatest.FunSpec
import org.scalatest.prop.PropertyChecks

class DFOrderingTest extends FunSpec with PropertyChecks {

  import DFOrdering.EdgeType._

  // This example comes from "Aho, Sethi, Ullman - Compilers: Principles, Techniques and Tool - Addison Wesley"
  val graph = Relation(Seq(1 -> 3, 1 -> 2, 2 -> 3, 3 -> 4, 4 -> 6, 4 -> 5, 4 -> 8, 5 -> 7, 6 -> 7, 7 -> 4, 7 -> 8, 8 -> 4, 8 -> 3, 8 -> 10, 8 -> 9, 9 -> 1, 10 -> 7))
  val heads = Set(1, 3, 4, 7)
  val sequence = 1 to 10
  val advancing = Set(1 -> 2, 1 -> 3, 3 -> 4, 4 -> 5, 4 -> 6, 6 -> 7, 7 -> 8, 8 -> 9, 8 -> 10, 4 -> 8)
  val retreating = Set(10 -> 7, 9 -> 1, 8 -> 3, 7 -> 4, 4 -> 3)
  val cross = Set(2 -> 3, 5 -> 7)

  val graph2 = Relation(Seq(1 -> 2, 1 -> 3, 2 -> 3, 3 -> 4, 4 -> 6, 4 -> 5, 4 -> 8, 5 -> 7, 6 -> 7, 7 -> 4, 7 -> 8, 8 -> 4, 8 -> 3, 8 -> 9, 8 -> 10, 9 -> 1, 10 -> 7))
  val sequence2 = (1 to 8).toList :+ 10 :+ 9

  describe("The depth-first ordering generated by the example graph") {
    val o = DFOrdering(graph, sequence, List(1))

    it("has the correct sequence") {
      assertResult(sequence)(o.toSeq)
    }

    it("has the correct heads") {
      for (x <- sequence) assertResult(heads contains x)(o.isHead(x))
    }
    it("has the correct edge types") {
      for ((u, v) <- advancing) {
        assertResult(Advancing, s"($u,$v)")(o.edgeType(u, v))
      }
    }
    for ((u, v) <- retreating) {
      assertResult(Retreating)(o.edgeType(u, v))
    }
    for ((u, v) <- cross) {
      assertResult(Cross)(o.edgeType(u, v))
    }

    it("implements the correct ordering") {
      for (x <- sequence; y <- sequence) {
        assertResult(scala.math.signum(sequence.indexOf(x) compare sequence.indexOf(y)), s"$x <= $y") {
          scala.math.signum(o.compare(x, y))
        }
      }
    }

    describe("The depth-first ordering generated by a permutation of the example graph") {
      it("has a different ordering of elements") {
        val o2 = DFOrdering(graph2, sequence2, List(1))
        assertResult(sequence2)(o2.toSeq)
      }
    }
  }
}